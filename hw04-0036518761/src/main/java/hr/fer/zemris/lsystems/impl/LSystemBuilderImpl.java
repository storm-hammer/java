package hr.fer.zemris.lsystems.impl;

import java.awt.Color;
import hr.fer.zemris.lsystems.LSystem;
import hr.fer.zemris.lsystems.LSystemBuilder;
import hr.fer.zemris.lsystems.LSystemBuilderProvider;
import hr.fer.zemris.lsystems.Painter;
import hr.fer.zemris.lsystems.impl.commands.*;

/**
 * The class is an implementation of a configurable <code>LSystem</code> builder
 * 
 * @author Mislav Prce
 */
@SuppressWarnings("unused")
public class LSystemBuilderImpl implements LSystemBuilder, LSystemBuilderProvider {
	
	private Dictionary<Character, Command> commands;
	private Dictionary<Character, String> productions;
	
	private double unitLength = 0.1;
	private double unitLengthDegreeScaler = 1;
	private Vector2D origin = new Vector2D(0, 0);
	private double angle = 0;
	private String axiom = "";
	
	/**
	 * The default constructor.
	 */
	public LSystemBuilderImpl() {
		super();
		this.commands = new Dictionary<>();
		this.productions = new Dictionary<>();
	}
	
	/**
	 * The class is an implementation of an <code>LSystem</code>
	 * 
	 * @author Mislav Prce
	 */
	private class LSystemNested implements LSystem {
		
		/**
		 * The method executes the commands for every character of the generated string of the system.
		 * 
		 * @param level the number of times productions are applied to the generated string of the system
		 * @param painter the painter which is used to draw the <code>LSystem</code> on the GUI
		 */
		@Override
		public void draw(int level, Painter painter) {
			
			Context ctx = new Context();
			TurtleState state = new TurtleState(origin, new Vector2D(1, 0), new Color(0,0,0), unitLength);
			
			ctx.pushState(state);
			String sequence = generate(level);
			ctx.getCurrentState().setEffectiveLength(ctx.getCurrentState().getEffectiveLength() * 
					Math.pow(unitLengthDegreeScaler, level));
			
			for(int i = 0, len = sequence.length(); i < len; i++) {
				Command c = commands.get(sequence.charAt(i));
				if(c != null) {
					c.execute(ctx, painter);
				}
			}
		}
		
		/**
		 * The method generates a string by applying productions to every character
		 * of the current axiom for a <code>level</code> number of times.
		 * 
		 * @param level the number of times 
		 * @return a string which was generated by applying productions to the characters of 
		 * the starting axiom or the generated string for the previous level if the level is more than 0;
		 * the current axiom otherwise
		 */
		@Override
		public String generate(int level) {
			
			if(level == 0) {
				return axiom;
			}
			
			String currentString = axiom;
			
			for(int i = 0; i < level; i++) {
				StringBuilder sb = new StringBuilder();
				
				for(int j = 0; j < currentString.length(); j++) {

					char c = currentString.charAt(j);
					String prod = productions.get(c);
					
					if(prod != null) {
						sb.append(prod);
					} else {
						sb.append(c);
					}

				}
				currentString = sb.toString();
			}
			return currentString;
		}
		
	}
	
	/**
	 * The method returns a new instance of an <code>LSystem</code>.
	 * 
	 * @return a new instance of an <code>LSystem</code>
	 */
	@Override
	public LSystem build() {
		return new LSystemNested();
	}
	
	/**
	 * The method configures the parameters of the system builder considering the
	 * contents of the given array of strings.
	 * 
	 * @param text the arrays of strings according to which the system builder is configured
	 * @return the system builder object that was configured
	 */
	@Override
	public LSystemBuilder configureFromText(String[] text) {
		
		for(int i = 0; i < text.length; i++) {
			
			String[] parts = text[i].split("\\s+");
			
			switch(parts[0]) {
			
				case "origin" -> setOrigin(Double.parseDouble(parts[1]), Double.parseDouble(parts[2]));
				
				case "angle" -> setAngle(Double.parseDouble(parts[1]));
				
				case "unitLength" -> setUnitLength(Double.parseDouble(parts[1]));
				
				case "unitLengthDegreeScaler" -> {
					if(parts.length == 2) {
						setUnitLengthDegreeScaler(Double.parseDouble(parts[1]));
					} else if(parts.length == 4){
						setUnitLengthDegreeScaler(Double.parseDouble(parts[1]) / Double.parseDouble(parts[3]));
					} else {
						if(parts[1].contains("/")) {
							setUnitLengthDegreeScaler(Double.parseDouble(parts[1].split("/")[0]));
						} else {
							setUnitLengthDegreeScaler(Double.parseDouble(parts[2].split("/")[1]));
						}
					}
				}
				
				case "axiom" -> setAxiom(parts[1]);
				
				case "production" -> registerProduction(parts[1].charAt(0), parts[2]);
				
				case "command" -> {
					StringBuilder sb = new StringBuilder();
					for(int j = 2; j < parts.length; j++) {
						sb.append(parts[j] + " ");
					}
					registerCommand(parts[1].charAt(0), sb.toString());
				}
			}
			
		}
		return this;
	}
	
	/**
	 * The method adds a new command to the current system builder.
	 * 
	 * @param character the character to which the given command is connected to
	 * @param command the command connected to the given character
	 * @return the object to which a new command was added
	 */
	@Override
	public LSystemBuilder registerCommand(char character, String command) {
		
		Command c = null;
		
		String[] parts = command.split("\\s+");
		
		switch(parts[0]) {
		
			case "pop" -> c = new PopCommand();
				
			case "push" -> c = new PushCommand();

			case "draw" -> {
				double step = Double.parseDouble(parts[1]);
				c = new DrawCommand(step);
			}
			case "skip" -> {
				double step = Double.parseDouble(parts[1]);
				c = new SkipCommand(step);
			}
			case "scale" -> {
				double factor = Double.parseDouble(parts[1]);
				c = new ScaleCommand(factor);
				break;
			}
			case "color" -> {
				Color color = Color.decode("#"+parts[1]);
				c = new ColorCommand(color);
			}
			case "rotate" -> {
				double angle = Double.parseDouble(parts[1]);
				c = new RotateCommand(angle);
			}
			default -> c = null;
		}
		
		if(c == null)
			throw new IllegalArgumentException("Unknown command!");
		
		commands.put(character, c);
		return this;
	}
	
	/**
	 * The method adds a new production to the current system builder.
	 * 
	 * @param character the character to which the given production is connected to
	 * @param production the production connected to the given character
	 * @return the object to which a new production was added
	 */
	@Override
	public LSystemBuilder registerProduction(char character, String production) {
		productions.put(character, production);
		return this;
	}
	
	/**
	 * The method sets the angle of the system builder.
	 * 
	 * @param angle the new angle of the system builder
	 * @return the object whose angle was modified
	 */
	@Override
	public LSystemBuilder setAngle(double angle) {
		this.angle = angle;
		return this;
	}
	
	/**
	 * The method sets the axiom of the system builder.
	 * 
	 * @param axiom the new axiom of the system builder
	 * @return the object whose axiom was modified
	 */
	@Override
	public LSystemBuilder setAxiom(String axiom) {
		this.axiom = axiom;
		return this;
	}
	
	/**
	 * The method sets the origin of the system builder.
	 * 
	 * @param x the x-coordinate of the new origin of the system builder
	 * @param y the y-coordinate of the new origin of the system builder
	 * @return the object whose origin was modified
	 */
	@Override
	public LSystemBuilder setOrigin(double x, double y) {
		this.origin = new Vector2D(x, y);
		return this;
	}
	
	/**
	 * The method sets the unit length of the system builder.
	 * 
	 * @param unitLength the new unit length of the system builder
	 * @return the object whose unit length was modified
	 */
	@Override
	public LSystemBuilder setUnitLength(double unitLength) {
		this.unitLength = unitLength;
		return this;
	}
	
	/**
	 * The method sets the unit length degree scaler of the system builder.
	 * 
	 * @param unitLengthDegreeScaler the new unit length degree scaler of the system builder
	 * @return the object whose unit length degree scaler was modified
	 */
	@Override
	public LSystemBuilder setUnitLengthDegreeScaler(double unitLengthDegreeScaler) {
		this.unitLengthDegreeScaler = unitLengthDegreeScaler;
		return this;
	}
	
	/**
	 * The method returns a new <code>LSystemBuilder</code>.
	 * 
	 * @return a new <code>LSystemBuilder</code>
	 */
	@Override
	public LSystemBuilder createLSystemBuilder() {
		return new LSystemBuilderImpl();
	}
}
